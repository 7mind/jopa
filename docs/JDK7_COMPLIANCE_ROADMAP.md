# JDK 7 Compliance Failure Analysis & Roadmap

**Date:** 2025-12-02
**Status:** 87.8% Pass Rate (668/761)
**Remaining Failures:** 93

## 1. Failure Categories

### 1.1 Aggressive Type Erasure (Generic Member Access)
**Impact:** High (Causes widespread failures in boxing, foreach, and generic method calls)
**Description:** When accessing members of a parameterized type (e.g., `Iterable<Integer>`) or a bounded type variable (e.g., `E extends B<?>`), the compiler frequently treats the return type of methods as `java.lang.Object` (the erasure) instead of the substituted type or bound.
**Symptoms:**
*   ~~`boxing/BoxedForeach.java`: `for (int i : iterableOfInteger)` fails because `next()` returns `Object`.~~ **FIXED (2025-12-02)**
*   ~~`cast/6569057/T6569057.java`: `x.get()` fails because `get()` is not found on `Object` (erasure of `E`).~~ **FIXED (2025-12-02)**
*   ~~`generics/inference/6369605/T6369605a.java`: Generic method return types degrade to `Object`.~~ **FIXED (2025-12-02)**

### 1.2 Missing Target Type Inference ✅ LARGELY ADDRESSED (2025-12-02)
**Impact:** Medium (Affects generic methods called without arguments)
**Description:** The compiler fails to infer type arguments based on the context (assignment target) when explicit arguments are missing or insufficient.
**Symptoms:**
*   ~~`String s = empty()` where `empty` is `<T> T empty()`: Fails to infer `T` and defaults to `Object`.~~ **FIXED (2025-12-02)**

### 1.3 Missing API Stubs (Infrastructure)
**Impact:** Medium (Affects specific tool tests)
**Description:** Tests for `javadoc` and `javac` API fail because the runtime environment lacks the necessary internal API stubs.
**Symptoms:**
*   `javadoc/...`: `Type "Tester" was not found` (Tester depends on missing `com.sun.javadoc.*`).
*   `api/TestJavacTask.java`: `No applicable overload ... enter(Iterable)` (Missing/Incorrect stub for `JavacTaskImpl`).

### 1.4 Bridge Method Generation
**Impact:** Low (Runtime behavior/Bytecode verification)
**Description:** Tests checking for the existence or properties of bridge methods fail or trigger warnings.
**Symptoms:**
*   `generics/Bridge*.java`: Failures related to missing or incorrect bridge methods in the generated bytecode.

---

## 2. Completed Work

### Phase 1a: Foreach Loop Type Extraction ✅ COMPLETE (2025-12-02)

**Problem:** Foreach loops over parameterized Iterables (e.g., `List<String>`) were treating the element type as `Object` instead of the actual type argument.

**Root Causes Fixed:**
1. **Type argument chaining through inheritance** (`body.cpp:743-757`): When traversing `List<E> → Collection<E> → Iterable<E>`, the recursive type argument substitution was using the wrong context. Fixed by passing `super_type` instead of `concrete_type` in recursive calls to `FindIterableTypeArgumentInSuper`.

2. **Class signature parsing** (`codegen/class.cpp`): Parameterized interface signatures were being parsed correctly but the stub runtime jar wasn't being rebuilt. Verified that signature generation now correctly outputs parameterized interfaces (e.g., `Ljava/lang/Iterable<TE;>;`).

3. **Unboxing + widening in foreach** (`body.cpp:998-1028`, `bytecode_stmt.cpp:3157-3182`):
   - Added `iterator_element_type` field to `AstForeachStatement` to store the actual element type from the iterator
   - Semantic analysis now validates unboxing+widening conversions (e.g., `Integer` → `int` → `float`)
   - Bytecode generation uses the stored element type for CHECKCAST before unboxing

**Tests Added:**
- `test/foreach/BoxedForeachTest.java`: Comprehensive test covering all boxing/unboxing/widening scenarios

**Results:**
- `boxing/BoxedForeach.java`: Now passes
- Primary test suite: 214/214 tests pass

### Phase 1b: Method Lookup on Type Variables ✅ COMPLETE (2025-12-02)

**Problem:** When a method type parameter `E extends B<?>` was used as a formal parameter type, method lookup on the variable treated it as `Object` instead of using the bound `B`.

**Root Cause Fixed:**
`ProcessMethodTypeParameters` in `decl.cpp:1046-1060` was not checking nested classes in the containing type when looking up bounds. For `<E extends B<?>>` where `B` is a nested class, the simple name lookup failed.

**Fix Applied:**
Added nested class lookup in the containing type and enclosing types when resolving method type parameter bounds:
```cpp
// Check nested classes within the containing type
if (!bound_type && containing_type)
{
    bound_type = containing_type -> FindTypeSymbol(bound_name);
}

// Check enclosing types for nested classes
if (!bound_type && containing_type)
{
    for (TypeSymbol* enclosing = containing_type -> ContainingType();
         enclosing && !bound_type;
         enclosing = enclosing -> ContainingType())
    {
        bound_type = enclosing -> FindTypeSymbol(bound_name);
    }
}
```

**Results:**
- `cast/6569057/T6569057.java`: Now passes
- Primary test suite: 214/214 tests pass
- Minor regression: `T6650759i.java` now fails due to complex recursive type bounds (`<U extends A<U, V>, V extends B<V>>`). This exposes a latent issue with type inference on recursive bounds. **UPDATE:** Now fixed by Phase 2!

### Phase 2: Target Type Inference ✅ COMPLETE (2025-12-02)

**Problem:** Generic methods with no arguments (e.g., `<T> T empty()`) couldn't be assigned to a typed variable (e.g., `String s = empty()`) because the type parameter defaulted to `Object`.

**Fix Applied:**

1. **Track uninferred type parameters** (`ast.h`): Added `needs_target_type_inference` flag to `AstMethodInvocation` to mark method calls where the return type is a type parameter that couldn't be inferred from arguments.

2. **Set flag during type inference** (`expr_primary.cpp:1190-1195`): After all argument-based inference attempts fail, set the flag to allow target type inference.

3. **Apply target type in variable initializers** (`init.cpp:28-58`): After processing the initializer expression, if it's a method call needing target type inference and the variable type is compatible, use the variable type as the inferred return type.

4. **Apply target type in assignments** (`expr_ops.cpp:3237-3267`): Same logic for regular assignment expressions.

**Results:**
- 6 tests now pass that were failing:
  - `generics/inference/6369605/T6369605a.java`
  - `generics/inference/6995200/T6995200.java`
  - `generics/inference/6359106/T6359106.java`
  - `generics/NameOrder.java`
  - `generics/odersky/Test4.java`
  - `generics/inference/6650759/T6650759i.java` (Phase 1b regression now fixed!)
- Primary test suite: 214/214 tests pass
- JDK7 compliance: 668/761 (87.8%)

---

## 3. Roadmap to 95%+ Compliance

### Phase 3: Expand API Stubs
**Goal:** Make tool tests pass.
**Status:** Not started (lower priority - infrastructure work)
**Approach:**
1. **`runtime/com/sun/javadoc`**: Add `RootDoc`, `Doclet`, `ClassDoc`, etc.
2. **`runtime/com/sun/tools/javac/api`**: Add/Update `JavacTask`, `JavacTaskImpl` with correct signatures.

### Phase 4: Bridge Methods (Cleanup)
**Goal:** Bytecode correctness.
**Status:** Not started (low priority)
**Approach:**
1. Review `GenerateBridgeMethods`: Ensure bridges are generated for covariant return types in interfaces and abstract classes.

---

## 4. Recommendation

**Phases 1a, 1b, and 2 are now complete!** The compiler now handles:
- Foreach loops over parameterized Iterables
- Method lookup on bounded type variables
- Target type inference for generic methods

The remaining 93 failing tests fall into these categories:
1. **API stubs** (~25 tests): javadoc, javac API tests need internal stubs
2. **Advanced generics** (~40 tests): Complex wildcard capture, recursive bounds, bridge methods
3. **Misc** (~28 tests): Multi-catch, diagnostics, other features

The next priority should be **Phase 3 (API Stubs)** if tool tests are important, or focus on the remaining generics issues in `generics/wildcards/`, `generics/rare/`, etc.
